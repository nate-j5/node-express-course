- In this lesson, you created a middleware function called asyncWrapper. Why?

- This was so that we don't to repeat the try catch in each route. 
The asyncWrapper handles the try catch logic and wraps the callback function in the asyncWrapper function making the app easier to manage.

- Suppose that you want to make sure that both a status code and an error message are sent back to the user when they request the URL for a task that does not exist.
 Assume that youâ€™ve created a CustomAPIError class and an error handler that references that class. 
 
Complete the code:
const getTask = asyncWrapper(async (req, res, next) => {  
  const { id: taskID } = req.params;  
  const task = await Task.findOne({ _id: taskID });  
  if (!task) {  
    return next(CustomAPIError({ msg: `Issue with this request, please try again`}, 404 ))
  }  
  res.status(200).json({ task });  
});  